[CmdletBinding()]
param(
  [string]$OutCsv = ".\AD_Device_Inventory.csv",
  [int]$TimeoutSec = 6,
  [switch]$SkipUnreachable # if set, silently skip hosts we can't reach
)

$ErrorActionPreference = 'Stop'
Set-StrictMode -Version Latest

function Get-AdComputerDns {
  # Prefer RSAT ActiveDirectory if installed; else pure LDAP
  if (Get-Module -ListAvailable -Name ActiveDirectory) {
    try {
      Import-Module ActiveDirectory -ErrorAction Stop
      return (Get-ADComputer -Filter * -Properties DNSHostName |
        Where-Object { $_.DNSHostName } |
        Select-Object -ExpandProperty DNSHostName)
    } catch { }
  }

  # Fallback: LDAP
  try {
    $root = [ADSI]"LDAP://RootDSE"
    $base = "LDAP://{0}" -f $root.defaultNamingContext
    $ds = New-Object System.DirectoryServices.DirectorySearcher([ADSI]$base)
    $ds.Filter = "(&(objectClass=computer)(dnsHostName=*))"
    $ds.PropertiesToLoad.Add("dnshostname") | Out-Null
    $ds.PageSize = 1000
    ($ds.FindAll() | ForEach-Object { $_.Properties['dnshostname'][0] }) | Where-Object { $_ }
  } catch {
    throw "Failed to enumerate computers from AD/LDAP. $_"
  }
}

function Get-CimSnapshot {
  param([string]$ComputerName, [int]$TimeoutSec = 6)

  try {
    $s = New-CimSession -ComputerName $ComputerName -OperationTimeoutSec $TimeoutSec -ErrorAction Stop
  } catch {
    if ($PSBoundParameters.ContainsKey('SkipUnreachable')) { return $null }
    Write-Warning "Unreachable: $ComputerName â€” $_"
    return $null
  }

  try {
    $os  = Get-CimInstance -CimSession $s -Class Win32_OperatingSystem -ErrorAction SilentlyContinue
    $cs  = Get-CimInstance -CimSession $s -Class Win32_ComputerSystem -ErrorAction SilentlyContinue
    $cpu = Get-CimInstance -CimSession $s -Class Win32_Processor | Select-Object -First 1
    $c   = Get-CimInstance -CimSession $s -Class Win32_LogicalDisk -Filter "DeviceID='C:'" -ErrorAction SilentlyContinue
    $sb  = Get-CimInstance -CimSession $s -Namespace root\wmi -Class MS_SecureBoot -ErrorAction SilentlyContinue
    $tpm = Get-CimInstance -CimSession $s -Namespace root\CIMV2\Security\MicrosoftTpm -Class Win32_Tpm -ErrorAction SilentlyContinue
  } finally {
    if ($s) { Remove-CimSession $s }
  }

  if (-not $os) { return $null }

  [PSCustomObject]@{
    Hostname       = $ComputerName
    Domain         = $env:USERDNSDOMAIN
    Manufacturer   = $cs.Manufacturer
    Model          = $cs.Model
    CPUModel       = $cpu.Name
    Cores          = $cpu.NumberOfCores
    RAMGB          = [math]::Round(($cs.TotalPhysicalMemory / 1GB),1)
    DiskGB         = if ($c) { [math]::Round(($c.Size/1GB),0) } else { $null }
    SysDriveFreeGB = if ($c) { [math]::Round(($c.FreeSpace/1GB),0) } else { $null }
    OSName         = $os.Caption
    OSEdition      = $os.OperatingSystemSKU
    OSVersion      = $os.Version
    OSBuild        = $os.BuildNumber
    UEFI           = $true  # Most modern machines; UEFI exact detection varies without vendor WMI
    SecureBoot     = try { [bool]$sb.SecureBootEnabled } catch { $null }
    TPMPresent     = [bool]$tpm
    TPMVersion     = if ($tpm) { ($tpm.SpecVersion -join ',') } else { $null }
  }
}

Write-Host "Enumerating AD computers..." -ForegroundColor Cyan
$hosts = Get-AdComputerDns | Sort-Object -Unique
Write-Host "Computers found: $($hosts.Count)" -ForegroundColor Cyan

$res = foreach ($h in $hosts) {
  $snap = Get-CimSnapshot -ComputerName $h -TimeoutSec $TimeoutSec
  if ($snap) { $snap }
}

$res | Export-Csv -Path $OutCsv -NoTypeInformation -Encoding UTF8
Write-Host "AD device inventory written: $OutCsv" -ForegroundColor Green
